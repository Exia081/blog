{"meta":{"title":"看山还是山","subtitle":"Exia的博客","description":"山重水复疑无路，柳暗花明又一村","author":"Exia","url":"https://exia081.github.io/blog","root":"/blog/"},"pages":[{"title":"tags","date":"2022-05-13T13:50:50.000Z","updated":"2022-05-13T13:52:35.019Z","comments":true,"path":"tags/index.html","permalink":"https://exia081.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-05-13T13:50:00.000Z","updated":"2022-05-13T13:50:20.865Z","comments":true,"path":"categories/index.html","permalink":"https://exia081.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CURL指南","slug":"CURL指南","date":"2022-05-18T13:35:11.000Z","updated":"2022-05-18T15:42:11.414Z","comments":true,"path":"2022/05/18/CURL指南/","link":"","permalink":"https://exia081.github.io/blog/2022/05/18/CURL%E6%8C%87%E5%8D%97/","excerpt":"","text":"简介大多数开发者都使用过CURL，但对它庞大的功能知之甚少，它支持的参数多达数五十多个,而且还在不断的增加 它的功能非常强大，熟练的话，完全可以满足我们日常大部分需求 常用参数以下内容主要介绍它的常用参数 主要内容来自 《curl cookbook》 ，阮一峰老师的CURL用法指南命令手册介绍，使用命令curl –manual就可以查看它的全部介绍 GET请求GET请求相关的参数如下 参数 描述 例子 -G 将-d参数的内容改为GET参数 curl -G -d ‘q=kitties’ -d ‘count=20’ https://google.com/search 实际请求URL为https://google.com/search?q=kitties&amp;count=20 –data-urlencode 主要用于处理GET参数中包含空格的情况 –data-urlencode ‘comment=hello world’ POST请求 参数 描述 例子 -d post 数据 curl -d’login=emma＆password=123’-X POST https://google.com/login或者 curl -d ‘login=emma’ -d ‘password=123’ -X POST https://google.com/login -d @file 读取文件内容作为post内容 curl -d ‘@data.txt’ https://google.com/login 这样就直接读取data.txt内容向服务器发送 –data-urlencode 会对post内容进行urlencode curl –data-urlencode ‘comment=hello world’ https://google.com/login -F 向服务器上传二进制文件,并且设置上传类型和文件名 curl -F ‘file=@photo.png;type=image/png;filename=me.png’ https://google.com/profile 上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为application/octet-stream filename 指定服务器收到的文件名 设置header相关参数 参数 描述 例子 -A 设置user-agent curl -A ‘Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 SaHari/537.36’ https://google.com -H 指定对应的header，可以多个-H连写 curl -H ‘Accept-Language: en-US’ -H ‘Secret-Message: xyzzy’ https://google.com -b 设置cookie，可以多个-b连写 curl -b ‘foo=bar’ https://google.com 向服务器发送一个名为foo，值为bar的cookie -b file 设置cookie文件 curl -b cookies.txt https://www.google.com -e 设置referer curl -e ‘https://google.com?q=example&#39; https://www.example.com -u 账号密码授权 curl -u ‘bob:12345’ https://google.com/login 引导设置 参数 描述 例子 -X 指定请求方式，GET，POST，HEAD，PUT等 curl -X POST https://www.example.com -L 允许重定向，默认CURL是不跟随重定向的 curl -L http://catonmat.net -x 设置代理 curl -x socks5://james:&#99;&#97;&#116;&#115;&#x40;&#109;&#x79;&#x70;&#x72;&#111;&#x78;&#x79;&#x2e;&#99;&#x6f;&#109;:8080 https://catonmat.net -k 跳过HTTPS校验，不检查证书是否正确 curl -k https://www.example.com –resolve HOST:PORT:ADDRESS 强制解析HOST到对应的IP:PORT，非常好用，可以配合通配符使用 curl https://datapixxxx.cn/ –resolve *:443:1.1.1.1 -K 或 –config FILE 指定配置文件,里面的内容按 每个参数一行进行设置 curl -K config.txt https://www.example.com 获取内容 参数 描述 例子 -c file 将服务器发送的cookie保存到对应的文件 curl -c cookies.txt https://www.google.com -o file 将服务器响应保存到文件 curl -o example.html https://www.example.com -v 打印整个请求过程，用于调试 curl -v https://www.example.com -i 打印服务器响应的header curl -i https://www.example.com -# 或者 –progress-bar 显示进度条 curl -# -i https://www.example.com 调试打印如果本地无法连接服务器，或响应很慢，我们肯定想知道是中间哪个环节出了问题 这时候就需要使用-w参数，打印一些请求过程的参数，方便我们排查问题 其中比较常用的参数如下 参数 描述 time_connect 建立TCP连接花费的时间 time_namelookup DNS查询花费的时间 time_total 全部完成花费时间 remote_ip 服务器IP remote_port 服务器端口 time_redirect 重定向花费时间，包括重定向的DNS查询到完成响应的时间 下面是一个简单的例子 1curl https://www.example.com -w &#x27;TCP连接时间:%&#123;time_connect&#125;\\nDNS时间:%&#123;time_namelookup&#125;\\n全部时间:%&#123;time_total&#125;\\n服务器IP:%&#123;remote_ip&#125;\\n&#x27; 响应如下： 1234TCP连接时间:1.154614DNS时间:0.000895全部时间:2.381030服务器IP:93.184.216.34","categories":[{"name":"LINUX命令","slug":"LINUX命令","permalink":"https://exia081.github.io/blog/categories/LINUX%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"LINUX命令","slug":"LINUX命令","permalink":"https://exia081.github.io/blog/tags/LINUX%E5%91%BD%E4%BB%A4/"}]},{"title":"GO Time包使用示例","slug":"Time包使用示例","date":"2022-05-14T13:46:06.000Z","updated":"2022-05-15T01:34:09.524Z","comments":true,"path":"2022/05/14/Time包使用示例/","link":"","permalink":"https://exia081.github.io/blog/2022/05/14/Time%E5%8C%85%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/","excerpt":"","text":"GO Time包使用示例在GO语言中,时间相关的包为time 我们可以直接看go源码的src文件，里面有关于timer这个包的test代码 下面列举部分常用的time相关函数 定时器time.After()在时间结束后往写入通道 例子如下： 12345678func ExampleAfter() &#123; select &#123; case m := &lt;-c: handle(m) case &lt;-time.After(10 * time.Second): fmt.Println(&quot;timed out&quot;) &#125;&#125; time.AfterFunc()固定时间后执行函数 123456789101112func TestAfterFunc(t *testing.T) &#123; c := make(chan bool) var f func() fmt.Println(&quot;开始：&quot; + time.Now().String()) f = func() &#123; fmt.Println(&quot;触发定时：&quot; + time.Now().String()) c &lt;- true &#125; time.AfterFunc(time.Second*10, f) &lt;-c&#125; 12开始：2022-05-14 22:53:18.706485 +0800 CST m=+0.000048501触发定时：2022-05-14 22:53:28.707644 +0800 CST m=+10.001264751 time.Tick()生成一个定时器，示例如下 1234c := time.Tick(5 * time.Second)for next := range c &#123; fmt.Printf(&quot;date：%v timeSteamp：%v\\n&quot;, next.Format(time.RFC3339), next.Unix())&#125; 12345/*date：2022-05-14T22:13:53+08:00 timeSteamp：1652537633date：2022-05-14T22:13:58+08:00 timeSteamp：1652537638date：2022-05-14T22:14:03+08:00 timeSteamp：1652537643*/ 这个例子很有意思，原因在于使用range来读取管道，而且并没有提供关闭这个通道的方法，文档提示它不能被GC回收，使用不当会导致内存泄漏 文档解释说：如果您的程序不需要释放关闭的情况下，使用这个方法是合理的 time.NewTicker()相比刚刚的tick函数，这个ticker似乎有更完善的机制 提供ticker.Stop来释放资源 提供ticker.Reset来重置 官方示例如下： 12345678910111213141516ticker := time.NewTicker(time.Second)defer ticker.Stop()done := make(chan bool)go func() &#123; time.Sleep(10 * time.Second) done &lt;- true&#125;()for &#123; select &#123; case &lt;-done: fmt.Println(&quot;Done!&quot;) return case t := &lt;-ticker.C: fmt.Println(&quot;Current time: &quot;, t) &#125;&#125; 定时器准确性定时器实际上也是由CPU轮询触发的，因此必定会遭遇系统中断等情况，导致实际触发时间有差异 一般而言，目前认为定时器能做到毫秒级的准确性 需要注意的是go在1.14版本之后的实现，由每个P队列挂载时间堆来实现 而堆的结构，顶部节点为最小值，所有的定时器，实际上就是往堆里面不断写入到期时间，即顶部的到期时间最近，他到期了，才有可能到下一层节点上的元素到期 因此涉及到 堆的更新和查询 目前定时器使用的堆为四叉堆，目的是为了降低层级，查询时间复杂度为O(log4 N)，查询时间有相比二叉堆有一定提升 Parse 解析时间官方的支持的时间解析格式并不是特别友好，建议使用carbon库来解决相关问题 TimeZone默认解释的时间区为UTC时间，一般情况下，我们转换为字符串时，需要改为 Asia/Shanghai时区 1234loc, _ := time.LoadLocation(&quot;Asia/Shanghai&quot;)const shortForm = &quot;2006-Jan-02&quot;t, _ = time.ParseInLocation(shortForm, &quot;2012-Jul-09&quot;, loc)fmt.Println(t) 时间间隔 （Duration）字符串解析 time.ParseDuration123456//根据字符串解释为时间间隔//格式 如 10h 1h10m10s 1µs 300ms// Valid time units are &quot;ns&quot;, &quot;us&quot; (or &quot;µs&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;.hours, _ := time.ParseDuration(&quot;10h&quot;)fmt.Printf(&quot;There are %.0f seconds in %v.\\n&quot;, hours.Seconds(), hours)// There are 36000 seconds in 10h0m0s. 计算时间间隔time.Since()如在一些任务执行完毕以后，计算它的耗时 1234567start := time.Now()//doSomethingtime.Sleep(time.Second * 2)defer func() &#123; timeSpent := time.Since(start) fmt.Println(&quot;consume time:&quot; + timeSpent.String())&#125;() 1consume time:2.001047625s time.Until()到某个时间的的间隔，负数表示在输入时间之前 总结定时器是很常见的包组件，它的精度是大家需要留意的。","categories":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/categories/GO%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/tags/GO%E8%AF%AD%E8%A8%80/"}]},{"title":"GO错误异常处理","slug":"GO错误异常处理","date":"2022-05-14T05:50:58.000Z","updated":"2022-05-14T15:44:59.812Z","comments":true,"path":"2022/05/14/GO错误异常处理/","link":"","permalink":"https://exia081.github.io/blog/2022/05/14/GO%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"错误处理在GO语言中处理错误，通过接口来处理 12345package builtintype error interface &#123; Error() string&#125; 在其他语言中，错误有可能是错误码，有可能是错误信息 错误处理非常重要，go语言将其统一成为接口，如果需要获取错误的信息，则调用error()接口，返回错误信息字符串，这统一了错误信息，都作为字符串输出 问题在错误处理的流程中，在其他语言中类似java，提供了try-catch-finally方式来处理，但go的err则会编写一大串对应的错误处理代码，显得非常冗长 123456789101112131415161718package mainfunc main() &#123; err := doSomething() if err != nil &#123; //handle error ... &#125; err = doSomething2() if err != nil &#123; //handle error ... &#125; err = doSomething3() if err != nil &#123; //handle error ... &#125;&#125; 这些问题在go的作者群体中，也产生过大量的讨论和修改建议，但目前没有形成统一的新的处理方案 FAQ里面也有提到 try-catch 会让代码变得非常混乱，对于真正的异常，作者希望通过panic-recover机制进行处理，这样代码看起来更简洁 1234567891011121314package mainfunc main() &#123; defer func() &#123; if err := recover(); err != nil &#123; //handle panic ... &#125; &#125;() err := doSomething() if err != nil &#123; //handle error ... &#125;&#125; 如何理解error事实上，作者们已经形成了很多醒世名言，下面抽选关于错误和异常相关的进行解释 123Errors are just a value.Don&#x27;t just check errors,handle them gracefully.Don&#x27;t panic. Errors are just a value.(错误只是一种值)事实上错误的处理可分为三种情况： Sentinel errors （哨兵错误） Error Types （类型错误） Opaque errors （黑盒错误） Sentinel errors （哨兵错误）通常情况下，出现某种错误，程序流程就不能继续往下执行了 但在实际使用过程中，往往会定义很多对应的哨兵错误，并且业务代码与它强耦合，这会导致引用很多包的时候，他们的错误意义是接近的，但却要写出大量意义相近的错误处理流程 12345if err == io.EOF &#123;//todo &#125; else if err == io.ErrUnexpectedEOF &#123;//todo &#125; Error Types （类型错误）它指的是实现了错误接口的类型错误，其中可以附带其他字段，提供更多信息，如 12345type BussinessError struct &#123; BusinessCode int Caller string Err error&#125; 在这个错误中，我们额外增加的 业务code，和调用者 等信息 通常在这种情况的错误处理，我们需要使用类型断言来进行处理，如 1234567891011func handleErr(err error) string &#123; switch err := err.(type) &#123; case BusinessError: return err.Error() case DBError: return err.Error() case CacheError: return err.Error() &#125; return &quot;&quot;&#125; 与哨兵错误类似，业务代码与它强耦合，增加了更多信息，方便根据信息处理不同的情况，减少了哨兵错误定义的数量，但大量错误逻辑仍然是需要 Opaque errors （黑盒错误）最后一种则是最直接的，不管接收到什么错误，都直接返回错误 123if err := doSomething(); err != nil &#123; return err&#125; Don’t just check errors,handle them gracefully.（优雅地处理错误）在GO语音中，提供了很多对错误进行优化处理的方案 123456//对error信息进行包装,并且带上调用栈信息errors.Wrap(err error, message string) error &#123;&#125;//按格式进行包装,并且带上调用栈信息errors.Wrapf(err error, format string, args ...interface&#123;&#125;) error//对error进行解包，实现cause接口的errorerrors.Cause(err error) error Only handle error once（只处理错误一次）在业务代码中，常常会写出很深的调用链 这时候如果每一层都对错误进行处理，如打印日志，则打印大量相同的日志 因此在GO的设计中，它希望的是最上层调用者进行处理，底层捕获的error，对其进行warp，这样就能暴露调用链，同时也不会在各个层级产生大量相同的错误处理代码 Don’t Panic (不要滥用异常)在GO语言的设计中，每个Gorutines都是独立的，因此并没有父子Gorutines的说法，更不能捕获其他gorutine的panic 在一个gorutine中没有设置defer recover函数，发生panic则后果是灾难，会导致整个go程序退出 在GO语言的作者中认为，只有发生不可挽回的事情，才需要触发panic，避免事故影响扩大 如果把panic当做error使用，则会导致无法正常区分哪些是灾难异常，哪些是业务错误 后续事实上，go目前的错误处理并不完美，在作者群体中，对go的错误处理也有广泛的讨论，并且把它作为go 2 版本的优化重点 我们可以对官方信息保持关注 Go 2 官方草案。","categories":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/categories/GO%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/tags/GO%E8%AF%AD%E8%A8%80/"}]},{"title":"Go编译参数","slug":"GO编译时参数","date":"2022-05-12T10:37:27.000Z","updated":"2022-05-13T13:54:27.230Z","comments":true,"path":"2022/05/12/GO编译时参数/","link":"","permalink":"https://exia081.github.io/blog/2022/05/12/GO%E7%BC%96%E8%AF%91%E6%97%B6%E5%8F%82%E6%95%B0/","excerpt":"","text":"Go编译时参数Go编译时，可以通过传入参数来定制编译过程的特征 具体参数可以通过 go help build 来进行查看 下面挑选一些常用的参数列举： 标准参数 参数 说明 -o 指定构建完成输出路径和文件名 -i 已废弃，安装指定的包来完成编译，编译需要的包会自动缓存下来 其他参数都被归类为build flags build flagsbuild flags在build,clean,get,install,list,run,test等命令下都是通用的 下面记录一些常用的参数 名称 描述 -tags ‘tag list’ （常用） 构建出带tag的版本. -gcflags ‘arg list’ （常用）编译参数go tool compile –help查看所有可用的参数 . -ldflags ‘flag list’ （常用）链接参数go tool link –help查看可用可用的参数 -mod （常用）readonly,vendor,mod 1.14版本以后，如果在mod文件里面有指定vendor，则默认使用vendor，否者设置为readonly -race （重要）同时检测数据竞争状态，只支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64. -trimpath （重要）删除编译包含的固定路径信息，如 -trimpath=$GOPATH，报错信息打印时只会包含文件的相对路径 -modfile 指定使用的modfile文件，但go.mod文件依然是需要的，用于确认编译包的根目录，gosum依然是需要的，如传入的xx.mod, 则需要或对应生成为 xx.sum -n 仅打印输出build需要的命令，不执行build动作（少用）。 -p n 开多少核cpu来并行编译，默认为本机CPU核数（少用）。 -v 打印出被编译的包名（少用）. -work 打印临时工作目录的名称，并在退出时不删除它（少用）。 -x 同时打印输出执行的命令名（-n）（少用）. gcflag编译参数，我们通过go tool compile -help包含哪些 下面列举一些常用的参数 名称 描述 -m （常用）打印优化信息 -N 禁用优化 (debug时用到） -l 禁止内联优化 (debug时用到） -c 指定编译时的的并发数，默认为1 -L 错误信息中打印文件全名 gcflag传入的方式为： -gcflag=”pattern= args”,其中pattern代表取值分别为 main,all,std,…,用于指定编译参数作用的范围，args则为对应的编译参数 gcflag 中的 patternpattern 是选择包的模式，它可以有以下几种定义: main: 表示 main 函数所在的顶级包路径 all: 表示 GOPATH 中的所有包。如果在 modules 模式下，则表示主模块和它所有的依赖，包括 test 文件的依赖 std: 表示 Go 标准库中的所有包 ...: ... 是一个通配符，可以匹配任意字符串(包括空字符串)。例如: 例如: net/... 表示 net 模块和它的所有子模块 ./... 表示当前主模块和所有子模块 注意: 如果 pattern 中包含了 / 和 ...，那么就不会匹配 vendor 目录 例如: ./... 不会匹配 ./vendor 目录。可以使用 ./vendor/... 匹配 vendor 目录和它的子模块 举例如下： 1go build -gcflags=&quot;main=-N -l&quot; . ldflag链接参数,我们通过go tool link –help 查看可用的参数 下面列举一些常用的参数 名称 描述 -X 注入变量，通常用于版本信息注入 举例如下 1go run -ldflags=&quot;-X main.who handsomeboy&quot; main.go","categories":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/categories/GO%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/tags/GO%E8%AF%AD%E8%A8%80/"}]}],"categories":[{"name":"LINUX命令","slug":"LINUX命令","permalink":"https://exia081.github.io/blog/categories/LINUX%E5%91%BD%E4%BB%A4/"},{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/categories/GO%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"LINUX命令","slug":"LINUX命令","permalink":"https://exia081.github.io/blog/tags/LINUX%E5%91%BD%E4%BB%A4/"},{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/tags/GO%E8%AF%AD%E8%A8%80/"}]}