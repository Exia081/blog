{"meta":{"title":"看山还是山","subtitle":"Exia的博客","description":"山重水复疑无路，柳暗花明又一村","author":"Exia","url":"https://exia081.github.io/blog","root":"/blog/"},"pages":[{"title":"tags","date":"2022-05-13T13:50:50.000Z","updated":"2022-05-13T13:52:35.019Z","comments":true,"path":"tags/index.html","permalink":"https://exia081.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-05-13T13:50:00.000Z","updated":"2022-05-13T13:50:20.865Z","comments":true,"path":"categories/index.html","permalink":"https://exia081.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"GO错误异常处理","slug":"GO错误异常处理","date":"2022-05-14T05:50:58.000Z","updated":"2022-05-14T07:49:08.464Z","comments":true,"path":"2022/05/14/GO错误异常处理/","link":"","permalink":"https://exia081.github.io/blog/2022/05/14/GO%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"错误处理在GO语言中处理错误，通过接口来处理 12345package builtintype error interface &#123; Error() string&#125; 在其他语言中，错误有可能是错误码，有可能是错误信息 错误处理非常重要，go语言将其统一成为接口，如果需要获取错误的信息，则调用error()接口，返回错误信息字符串，这统一了错误信息，都作为字符串输出 问题在错误处理的流程中，在其他语言中类似java，提供了try-catch-finally方式来处理，但go的err则会编写一大串对应的错误处理代码，显得非常冗长 123456789101112131415161718package mainfunc main() &#123; err := doSomething() if err != nil &#123; //handle error ... &#125; err = doSomething2() if err != nil &#123; //handle error ... &#125; err = doSomething3() if err != nil &#123; //handle error ... &#125;&#125; 这些问题在go的作者群体中，也产生过大量的讨论和修改建议，但目前没有形成统一的新的处理方案 FAQ里面也有提到 try-catch 会让代码变得非常混乱，对于真正的异常，作者希望通过panic-recover机制进行处理，这样代码看起来更简洁 1234567891011121314package mainfunc main() &#123; defer func() &#123; if err := recover(); err != nil &#123; //handle panic ... &#125; &#125;() err := doSomething() if err != nil &#123; //handle error ... &#125;&#125; 如何理解error事实上，作者们已经形成了很多醒世名言，下面抽选关于错误和异常相关的进行解释 123Errors are just a value.Don&#x27;t just check errors,handle them gracefully.Don&#x27;t panic. Errors are just a value.(错误只是一种值)事实上错误的处理可分为三种情况： Sentinel errors （哨兵错误） Error Types （类型错误） Opaque errors （黑盒错误） Sentinel errors （哨兵错误）通常情况下，出现某种错误，程序流程就不能继续往下执行了 但在实际使用过程中，往往会定义很多对应的哨兵错误，并且业务代码与它强耦合，这会导致引用很多包的时候，他们的错误意义是接近的，但却要写出大量意义相近的错误处理流程 12345if err == io.EOF &#123;//todo &#125; else if err == io.ErrUnexpectedEOF &#123;//todo &#125; Error Types （类型错误）它指的是实现了错误接口的类型错误，其中可以附带其他字段，提供更多信息，如 12345type BussinessError struct &#123; BusinessCode int Caller string Err error&#125; 在这个错误中，我们额外增加的 业务code，和调用者 等信息 通常在这种情况的错误处理，我们需要使用类型断言来进行处理，如 1234567891011func handleErr(err error) string &#123; switch err := err.(type) &#123; case BusinessError: return err.Error() case DBError: return err.Error() case CacheError: return err.Error() &#125; return &quot;&quot;&#125; 与哨兵错误类似，业务代码与它强耦合，增加了更多信息，方便根据信息处理不同的情况，减少了哨兵错误定义的数量，但大量错误逻辑仍然是需要 Opaque errors （黑盒错误）最后一种则是最直接的，不管接收到什么错误，都直接返回错误 123if err := doSomething(); err != nil &#123; return err&#125; Don’t just check errors,handle them gracefully.（优雅地处理错误）在GO语音中，提供了很多对错误进行优化处理的方案 123456//对error信息进行包装,并且带上调用栈信息errors.Wrap(err error, message string) error &#123;&#125;//按格式进行包装,并且带上带上调用栈信息errors.Wrapf(err error, format string, args ...interface&#123;&#125;) error//对error进行解包，实现cause接口的errorerrors.Cause(err error) error Only handle error once（只处理错误一次）在业务代码中，常常会写出很深的调用链 这时候如果每一层都对错误进行处理，如打印日志，则打印大量相同的日志 因此在GO的设计中，它希望的是最上层调用者进行处理，底层捕获的error，对其进行warp，这样就能暴露调用链，同时也不会在各个层级产生大量相同的错误处理代码 Don’t Panic (不要滥用异常)在GO语言的设计中，每个Gorutines都是独立的，因此并没有父子Gorutines的说法，更不能捕获其他gorutine的panic 在一个gorutine中没有设置defer recover函数，发生panic则后果是灾难，会导致整个go程序退出 在GO语言的作者中认为，只有发生不可挽回的事情，才需要触发panic，避免事故影响扩大 如果把panic当做error使用，则会导致无法正常区分哪些是灾难异常，哪些是业务错误 后续事实上，go目前的错误处理并不完美，在作者群体中，对go的错误处理也有广泛的讨论，并且把它作为go 2 版本的优化重点 我们可以对官方信息保持关注 Go 2 官方草案。","categories":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/categories/GO%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/tags/GO%E8%AF%AD%E8%A8%80/"}]},{"title":"Go编译参数","slug":"GO编译时参数","date":"2022-05-12T10:37:27.000Z","updated":"2022-05-13T13:54:27.230Z","comments":true,"path":"2022/05/12/GO编译时参数/","link":"","permalink":"https://exia081.github.io/blog/2022/05/12/GO%E7%BC%96%E8%AF%91%E6%97%B6%E5%8F%82%E6%95%B0/","excerpt":"","text":"Go编译时参数Go编译时，可以通过传入参数来定制编译过程的特征 具体参数可以通过 go help build 来进行查看 下面挑选一些常用的参数列举： 标准参数 参数 说明 -o 指定构建完成输出路径和文件名 -i 已废弃，安装指定的包来完成编译，编译需要的包会自动缓存下来 其他参数都被归类为build flags build flagsbuild flags在build,clean,get,install,list,run,test等命令下都是通用的 下面记录一些常用的参数 名称 描述 -tags ‘tag list’ （常用） 构建出带tag的版本. -gcflags ‘arg list’ （常用）编译参数go tool compile –help查看所有可用的参数 . -ldflags ‘flag list’ （常用）链接参数go tool link –help查看可用可用的参数 -mod （常用）readonly,vendor,mod 1.14版本以后，如果在mod文件里面有指定vendor，则默认使用vendor，否者设置为readonly -race （重要）同时检测数据竞争状态，只支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64. -trimpath （重要）删除编译包含的固定路径信息，如 -trimpath=$GOPATH，报错信息打印时只会包含文件的相对路径 -modfile 指定使用的modfile文件，但go.mod文件依然是需要的，用于确认编译包的根目录，gosum依然是需要的，如传入的xx.mod, 则需要或对应生成为 xx.sum -n 仅打印输出build需要的命令，不执行build动作（少用）。 -p n 开多少核cpu来并行编译，默认为本机CPU核数（少用）。 -v 打印出被编译的包名（少用）. -work 打印临时工作目录的名称，并在退出时不删除它（少用）。 -x 同时打印输出执行的命令名（-n）（少用）. gcflag编译参数，我们通过go tool compile -help包含哪些 下面列举一些常用的参数 名称 描述 -m （常用）打印优化信息 -N 禁用优化 (debug时用到） -l 禁止内联优化 (debug时用到） -c 指定编译时的的并发数，默认为1 -L 错误信息中打印文件全名 gcflag传入的方式为： -gcflag=”pattern= args”,其中pattern代表取值分别为 main,all,std,…,用于指定编译参数作用的范围，args则为对应的编译参数 gcflag 中的 patternpattern 是选择包的模式，它可以有以下几种定义: main: 表示 main 函数所在的顶级包路径 all: 表示 GOPATH 中的所有包。如果在 modules 模式下，则表示主模块和它所有的依赖，包括 test 文件的依赖 std: 表示 Go 标准库中的所有包 ...: ... 是一个通配符，可以匹配任意字符串(包括空字符串)。例如: 例如: net/... 表示 net 模块和它的所有子模块 ./... 表示当前主模块和所有子模块 注意: 如果 pattern 中包含了 / 和 ...，那么就不会匹配 vendor 目录 例如: ./... 不会匹配 ./vendor 目录。可以使用 ./vendor/... 匹配 vendor 目录和它的子模块 举例如下： 1go build -gcflags=&quot;main=-N -l&quot; . ldflag链接参数,我们通过go tool link –help 查看可用的参数 下面列举一些常用的参数 名称 描述 -X 注入变量，通常用于版本信息注入 举例如下 1go run -ldflags=&quot;-X main.who handsomeboy&quot; main.go","categories":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/categories/GO%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/tags/GO%E8%AF%AD%E8%A8%80/"}]}],"categories":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/categories/GO%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"GO语言","slug":"GO语言","permalink":"https://exia081.github.io/blog/tags/GO%E8%AF%AD%E8%A8%80/"}]}